(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.Searchbase = {}));
}(this, (function (exports) { 'use strict';

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  var Observable = /*#__PURE__*/function () {
    function Observable() {
      this.observers = [];
    }

    var _proto = Observable.prototype;

    _proto.subscribe = function subscribe(fn, propertiesToSubscribe) {
      this.observers.push({
        callback: fn,
        properties: propertiesToSubscribe
      });
    };

    _proto.unsubscribe = function unsubscribe(fn) {
      if (fn) {
        this.observers = this.observers.filter(function (item) {
          if (item.callback !== fn) {
            return item;
          }

          return null;
        });
      } else {
        this.observers = [];
      }
    };

    _proto.next = function next(o, property, thisObj) {
      var scope = thisObj;

      if (!scope && window) {
        scope = window;
      }

      this.observers.forEach(function (item) {
        // filter by subscribed properties
        if (item.properties === undefined) {
          item.callback.call(scope, o);
        } else if (item.properties instanceof Array && item.properties.length && item.properties.includes(property)) {
          item.callback.call(scope, o);
        } else if (typeof item.properties === 'string' && item.properties && item.properties === property) {
          item.callback.call(scope, o);
        }
      });
    };

    return Observable;
  }();

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var browserPonyfill = createCommonjsModule(function (module, exports) {
    var __self__ = function (root) {
      function F() {
        this.fetch = false;
        this.DOMException = root.DOMException;
      }

      F.prototype = root;
      return new F();
    }(typeof self !== 'undefined' ? self : commonjsGlobal);

    (function (self) {
      var irrelevant = function (exports) {
        var support = {
          searchParams: 'URLSearchParams' in self,
          iterable: 'Symbol' in self && 'iterator' in Symbol,
          blob: 'FileReader' in self && 'Blob' in self && function () {
            try {
              new Blob();
              return true;
            } catch (e) {
              return false;
            }
          }(),
          formData: 'FormData' in self,
          arrayBuffer: 'ArrayBuffer' in self
        };

        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }

        if (support.arrayBuffer) {
          var viewClasses = ['[object Int8Array]', '[object Uint8Array]', '[object Uint8ClampedArray]', '[object Int16Array]', '[object Uint16Array]', '[object Int32Array]', '[object Uint32Array]', '[object Float32Array]', '[object Float64Array]'];

          var isArrayBufferView = ArrayBuffer.isView || function (obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }

        function normalizeName(name) {
          if (typeof name !== 'string') {
            name = String(name);
          }

          if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
            throw new TypeError('Invalid character in header field name');
          }

          return name.toLowerCase();
        }

        function normalizeValue(value) {
          if (typeof value !== 'string') {
            value = String(value);
          }

          return value;
        } // Build a destructive iterator for the value list


        function iteratorFor(items) {
          var iterator = {
            next: function next() {
              var value = items.shift();
              return {
                done: value === undefined,
                value: value
              };
            }
          };

          if (support.iterable) {
            iterator[Symbol.iterator] = function () {
              return iterator;
            };
          }

          return iterator;
        }

        function Headers(headers) {
          this.map = {};

          if (headers instanceof Headers) {
            headers.forEach(function (value, name) {
              this.append(name, value);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function (header) {
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function (name) {
              this.append(name, headers[name]);
            }, this);
          }
        }

        Headers.prototype.append = function (name, value) {
          name = normalizeName(name);
          value = normalizeValue(value);
          var oldValue = this.map[name];
          this.map[name] = oldValue ? oldValue + ', ' + value : value;
        };

        Headers.prototype['delete'] = function (name) {
          delete this.map[normalizeName(name)];
        };

        Headers.prototype.get = function (name) {
          name = normalizeName(name);
          return this.has(name) ? this.map[name] : null;
        };

        Headers.prototype.has = function (name) {
          return this.map.hasOwnProperty(normalizeName(name));
        };

        Headers.prototype.set = function (name, value) {
          this.map[normalizeName(name)] = normalizeValue(value);
        };

        Headers.prototype.forEach = function (callback, thisArg) {
          for (var name in this.map) {
            if (this.map.hasOwnProperty(name)) {
              callback.call(thisArg, this.map[name], name, this);
            }
          }
        };

        Headers.prototype.keys = function () {
          var items = [];
          this.forEach(function (value, name) {
            items.push(name);
          });
          return iteratorFor(items);
        };

        Headers.prototype.values = function () {
          var items = [];
          this.forEach(function (value) {
            items.push(value);
          });
          return iteratorFor(items);
        };

        Headers.prototype.entries = function () {
          var items = [];
          this.forEach(function (value, name) {
            items.push([name, value]);
          });
          return iteratorFor(items);
        };

        if (support.iterable) {
          Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
        }

        function consumed(body) {
          if (body.bodyUsed) {
            return Promise.reject(new TypeError('Already read'));
          }

          body.bodyUsed = true;
        }

        function fileReaderReady(reader) {
          return new Promise(function (resolve, reject) {
            reader.onload = function () {
              resolve(reader.result);
            };

            reader.onerror = function () {
              reject(reader.error);
            };
          });
        }

        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob);
          return promise;
        }

        function readBlobAsText(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsText(blob);
          return promise;
        }

        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf);
          var chars = new Array(view.length);

          for (var i = 0; i < view.length; i++) {
            chars[i] = String.fromCharCode(view[i]);
          }

          return chars.join('');
        }

        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0);
          } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
          }
        }

        function Body() {
          this.bodyUsed = false;

          this._initBody = function (body) {
            this._bodyInit = body;

            if (!body) {
              this._bodyText = '';
            } else if (typeof body === 'string') {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer); // IE 10-11 can't handle a DataView body.

              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }

            if (!this.headers.get('content-type')) {
              if (typeof body === 'string') {
                this.headers.set('content-type', 'text/plain;charset=UTF-8');
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set('content-type', this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
              }
            }
          };

          if (support.blob) {
            this.blob = function () {
              var rejected = consumed(this);

              if (rejected) {
                return rejected;
              }

              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error('could not read FormData body as blob');
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };

            this.arrayBuffer = function () {
              if (this._bodyArrayBuffer) {
                return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
              } else {
                return this.blob().then(readBlobAsArrayBuffer);
              }
            };
          }

          this.text = function () {
            var rejected = consumed(this);

            if (rejected) {
              return rejected;
            }

            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error('could not read FormData body as text');
            } else {
              return Promise.resolve(this._bodyText);
            }
          };

          if (support.formData) {
            this.formData = function () {
              return this.text().then(decode);
            };
          }

          this.json = function () {
            return this.text().then(JSON.parse);
          };

          return this;
        } // HTTP methods whose capitalization should be normalized


        var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method;
        }

        function Request(input, options) {
          options = options || {};
          var body = options.body;

          if (input instanceof Request) {
            if (input.bodyUsed) {
              throw new TypeError('Already read');
            }

            this.url = input.url;
            this.credentials = input.credentials;

            if (!options.headers) {
              this.headers = new Headers(input.headers);
            }

            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;

            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }

          this.credentials = options.credentials || this.credentials || 'same-origin';

          if (options.headers || !this.headers) {
            this.headers = new Headers(options.headers);
          }

          this.method = normalizeMethod(options.method || this.method || 'GET');
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal;
          this.referrer = null;

          if ((this.method === 'GET' || this.method === 'HEAD') && body) {
            throw new TypeError('Body not allowed for GET or HEAD requests');
          }

          this._initBody(body);
        }

        Request.prototype.clone = function () {
          return new Request(this, {
            body: this._bodyInit
          });
        };

        function decode(body) {
          var form = new FormData();
          body.trim().split('&').forEach(function (bytes) {
            if (bytes) {
              var split = bytes.split('=');
              var name = split.shift().replace(/\+/g, ' ');
              var value = split.join('=').replace(/\+/g, ' ');
              form.append(decodeURIComponent(name), decodeURIComponent(value));
            }
          });
          return form;
        }

        function parseHeaders(rawHeaders) {
          var headers = new Headers(); // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
          // https://tools.ietf.org/html/rfc7230#section-3.2

          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
          preProcessedHeaders.split(/\r?\n/).forEach(function (line) {
            var parts = line.split(':');
            var key = parts.shift().trim();

            if (key) {
              var value = parts.join(':').trim();
              headers.append(key, value);
            }
          });
          return headers;
        }

        Body.call(Request.prototype);

        function Response(bodyInit, options) {
          if (!options) {
            options = {};
          }

          this.type = 'default';
          this.status = options.status === undefined ? 200 : options.status;
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = 'statusText' in options ? options.statusText : 'OK';
          this.headers = new Headers(options.headers);
          this.url = options.url || '';

          this._initBody(bodyInit);
        }

        Body.call(Response.prototype);

        Response.prototype.clone = function () {
          return new Response(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers(this.headers),
            url: this.url
          });
        };

        Response.error = function () {
          var response = new Response(null, {
            status: 0,
            statusText: ''
          });
          response.type = 'error';
          return response;
        };

        var redirectStatuses = [301, 302, 303, 307, 308];

        Response.redirect = function (url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError('Invalid status code');
          }

          return new Response(null, {
            status: status,
            headers: {
              location: url
            }
          });
        };

        exports.DOMException = self.DOMException;

        try {
          new exports.DOMException();
        } catch (err) {
          exports.DOMException = function (message, name) {
            this.message = message;
            this.name = name;
            var error = Error(message);
            this.stack = error.stack;
          };

          exports.DOMException.prototype = Object.create(Error.prototype);
          exports.DOMException.prototype.constructor = exports.DOMException;
        }

        function fetch(input, init) {
          return new Promise(function (resolve, reject) {
            var request = new Request(input, init);

            if (request.signal && request.signal.aborted) {
              return reject(new exports.DOMException('Aborted', 'AbortError'));
            }

            var xhr = new XMLHttpRequest();

            function abortXhr() {
              xhr.abort();
            }

            xhr.onload = function () {
              var options = {
                status: xhr.status,
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || '')
              };
              options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
              var body = 'response' in xhr ? xhr.response : xhr.responseText;
              resolve(new Response(body, options));
            };

            xhr.onerror = function () {
              reject(new TypeError('Network request failed'));
            };

            xhr.ontimeout = function () {
              reject(new TypeError('Network request failed'));
            };

            xhr.onabort = function () {
              reject(new exports.DOMException('Aborted', 'AbortError'));
            };

            xhr.open(request.method, request.url, true);

            if (request.credentials === 'include') {
              xhr.withCredentials = true;
            } else if (request.credentials === 'omit') {
              xhr.withCredentials = false;
            }

            if ('responseType' in xhr && support.blob) {
              xhr.responseType = 'blob';
            }

            request.headers.forEach(function (value, name) {
              xhr.setRequestHeader(name, value);
            });

            if (request.signal) {
              request.signal.addEventListener('abort', abortXhr);

              xhr.onreadystatechange = function () {
                // DONE (success or failure)
                if (xhr.readyState === 4) {
                  request.signal.removeEventListener('abort', abortXhr);
                }
              };
            }

            xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
          });
        }

        fetch.polyfill = true;

        if (!self.fetch) {
          self.fetch = fetch;
          self.Headers = Headers;
          self.Request = Request;
          self.Response = Response;
        }

        exports.Headers = Headers;
        exports.Request = Request;
        exports.Response = Response;
        exports.fetch = fetch;
        return exports;
      }({});
    })(__self__);

    delete __self__.fetch.polyfill;
    exports = __self__.fetch; // To enable: import fetch from 'cross-fetch'

    exports["default"] = __self__.fetch; // For TypeScript consumers without esModuleInterop.

    exports.fetch = __self__.fetch; // To enable: import {fetch} from 'cross-fetch'

    exports.Headers = __self__.Headers;
    exports.Request = __self__.Request;
    exports.Response = __self__.Response;
    module.exports = exports;
  });
  var browserPonyfill_1 = browserPonyfill.fetch;
  var browserPonyfill_2 = browserPonyfill.Headers;
  var browserPonyfill_3 = browserPonyfill.Request;
  var browserPonyfill_4 = browserPonyfill.Response;

  function _extends$1() {
    _extends$1 = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends$1.apply(this, arguments);
  } // Function to parse the URL


  function btoa(input) {
    if (input === void 0) {
      input = '';
    }

    var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    var str = input;
    var output = ''; // eslint-disable-next-line

    for (var block = 0, charCode, i = 0, map = chars; str.charAt(i | 0) || (map = '=', i % 1); // eslint-disable-line no-bitwise
    output += map.charAt(63 & block >> 8 - i % 1 * 8) // eslint-disable-line no-bitwise
    ) {
      charCode = str.charCodeAt(i += 3 / 4);

      if (charCode > 0xff) {
        throw new Error('"btoa" failed: The string to be encoded contains characters outside of the Latin1 range.');
      }

      block = block << 8 | charCode; // eslint-disable-line no-bitwise
    }

    return output;
  }

  function validateIndex(index) {
    if (!index) {
      throw new Error('appbase-analytics: A valid index must be present to record analytics events.');
    }
  }

  function validateCredentials(credentials) {
    if (!credentials) {
      throw new Error('appbase-analytics: Auth credentials is missing.');
    }
  }

  function validateURL(url) {
    if (!url) {
      throw new Error('appbase-analytics: URL is missing.');
    }
  }

  function validateQuery(query, queryID) {
    if ((query === undefined || query === null) && !queryID) {
      throw new Error('appbase-analytics: query or queryID must be present to register a click/conversion event');
    }
  }

  function validateClickObjects(objects) {
    if (!objects || Object.keys(objects).length < 1) {
      throw new Error('appbase-analytics: at least one click object must be present to register a click event');
    }
  }

  function validateConversionObjects(objects) {
    if (!objects || Object.keys(objects).length < 1) {
      throw new Error('appbase-analytics: at least one click object must be present to register a click event');
    }
  }

  function initClient(config) {
    if (config === void 0) {
      config = {};
    }

    var metrics = {
      credentials: config.credentials,
      index: config.index,
      url: config.url,
      userID: config.userID,
      globalEventData: config.globalEventData,
      queryID: '',
      headers: null
    };
    validateIndex(metrics.index);
    validateCredentials(metrics.credentials);
    validateURL(metrics.url);

    metrics._request = function (url, body, callback) {
      var finalBody = _extends$1({}, body, {
        user_id: metrics.userID,
        event_data: _extends$1({}, body && body.event_data, {}, metrics.globalEventData)
      });

      return browserPonyfill(metrics.url + "/" + metrics.index + "/_analytics/" + url, {
        method: 'PUT',
        headers: _extends$1({}, metrics.headers, {
          'Content-Type': 'application/json',
          Authorization: "Basic " + btoa(metrics.credentials)
        }),
        body: JSON.stringify(finalBody)
      }).then(function (response) {
        if (callback) {
          callback(null, response);
        }
      })["catch"](function (err) {
        console.error(err);

        if (callback) {
          callback(err, null);
        }
      });
    }; // To register a search


    metrics.search = function (searchConfig, callback) {
      validateQuery(searchConfig.query, searchConfig.queryID);

      var captureQueryID = function captureQueryID(err, res) {
        if (res) {
          res.json().then(function (response) {
            if (response && response.query_id) {
              metrics.queryID = response.query_id;
            }
          })["catch"](function (error) {
            console.error(error);
          });
        }

        if (callback) {
          callback(err, res);
        }
      }; // just to avoid the flow type error


      if (metrics._request) {
        var requestBody = {
          query: searchConfig.query,
          query_id: searchConfig.queryID,
          event_data: searchConfig.eventData,
          filters: searchConfig.filters,
          hits: searchConfig.hits
        };

        metrics._request('search', requestBody, captureQueryID);
      }
    }; // To register a click


    metrics.click = function (clickConfig, callback) {
      validateQuery(clickConfig.query, clickConfig.queryID);
      validateClickObjects(clickConfig.objects); // just to avoid the flow type error

      if (metrics._request) {
        var requestBody = {
          click_on: clickConfig.objects,
          click_type: clickConfig.isSuggestionClick ? 'suggestion' : 'result',
          query: clickConfig.query,
          query_id: clickConfig.queryID,
          event_data: clickConfig.eventData
        };

        metrics._request('click', requestBody, callback);
      }
    }; // To register a conversion


    metrics.conversion = function (conversionConfig, callback) {
      validateQuery(conversionConfig.query, conversionConfig.queryID);
      validateConversionObjects(conversionConfig.objects); // just to avoid the flow type error

      if (metrics._request) {
        var requestBody = {
          conversion_on: conversionConfig.objects,
          query: conversionConfig.query,
          query_id: conversionConfig.queryID,
          event_data: conversionConfig.eventData
        };

        metrics._request('conversion', requestBody, callback);
      }
    }; // Sets the userID


    metrics.setUserID = function (userID) {
      metrics.userID = userID;
    }; // Sets the global events


    metrics.setGlobalEventData = function (globalEvents) {
      metrics.globalEventData = globalEvents;
    }; // Sets the headers


    metrics.setHeaders = function (headers) {
      metrics.headers = headers;
    };

    return metrics;
  }

  var index = {
    init: initClient
  };

  function getErrorMessage(msg) {
    return "SearchBase: " + msg;
  }
  var errorMessages = {
    invalidIndex: getErrorMessage('Please provide a valid index.'),
    invalidURL: getErrorMessage('Please provide a valid url.'),
    invalidComponentId: getErrorMessage('Please provide component id.'),
    invalidDataField: getErrorMessage('Please provide data field.'),
    dataFieldAsArray: getErrorMessage('Only components with `search` type supports the multiple data fields. Please define `dataField` as a string.')
  };
  var popularSuggestionFields = ['key', 'key.autosuggest'];
  var queryTypes = {
    Search: 'search',
    Term: 'term',
    Geo: 'geo',
    Range: 'range'
  };
  var withClickIds = function withClickIds(results) {
    if (results === void 0) {
      results = [];
    }

    return results.map(function (result, index) {
      return _extends({}, result, {
        _click_id: index + 1
      });
    });
  };
  var highlightResults = function highlightResults(result) {
    var data = _extends({}, result);

    if (data.highlight) {
      Object.keys(data.highlight).forEach(function (highlightItem) {
        var _extends2;

        var highlightValue = data.highlight[highlightItem][0];
        data._source = _extends({}, data._source, (_extends2 = {}, _extends2[highlightItem] = highlightValue, _extends2));
      });
    }

    return data;
  };
  var parseHits = function parseHits(hits) {
    var results = [];

    if (hits) {
      results = [].concat(hits).map(function (item) {
        var data = highlightResults(item);
        var result = Object.keys(data).filter(function (key) {
          return key !== '_source';
        }).reduce(function (obj, key) {
          // eslint-disable-next-line
          obj[key] = data[key];
          return obj;
        }, _extends({}, data._source));
        return result;
      });
    }

    return results;
  };
  var getNormalizedField = function getNormalizedField(field) {
    if (field) {
      // if data field is string
      if (!Array.isArray(field)) {
        return [field];
      }

      if (field.length) {
        var fields = [];
        field.forEach(function (dataField) {
          if (typeof dataField === 'string') {
            fields.push(dataField);
          } else if (dataField.field) {
            // if data field is an array of objects
            fields.push(dataField.field);
          }
        });
        return fields;
      }
    }

    return undefined;
  };
  function isNumber(n) {
    return !Number.isNaN(parseFloat(n)) && Number.isFinite(n);
  }
  var getNormalizedWeights = function getNormalizedWeights(field) {
    if (field && Array.isArray(field) && field.length) {
      var weights = [];
      field.forEach(function (dataField) {
        if (isNumber(dataField.weight)) {
          // if data field is an array of objects
          weights.push(dataField.weight);
        } else {
          // Add default weight as 1 to maintain order
          weights.push(1);
        }
      });
      return weights;
    }

    return undefined;
  };
  function flatReactProp(reactProp, componentID) {
    var flattenReact = [];

    var flatReact = function flatReact(react) {
      if (react && Object.keys(react)) {
        Object.keys(react).forEach(function (r) {
          if (react[r]) {
            if (typeof react[r] === 'string') {
              flattenReact = [].concat(flattenReact, [react[r]]);
            } else if (Array.isArray(react[r])) {
              flattenReact = [].concat(flattenReact, react[r]);
            } else if (typeof react[r] === 'object') {
              flatReact(react[r]);
            }
          }
        });
      }
    };

    flatReact(reactProp); // Remove cyclic dependencies i.e dependencies on it's own

    flattenReact = flattenReact.filter(function (react) {
      return react !== componentID;
    });
    return flattenReact;
  } // flattens a nested array

  var flatten = function flatten(arr) {
    return arr.reduce(function (flat, toFlatten) {
      return flat.concat(Array.isArray(toFlatten) ? flatten(toFlatten) : toFlatten);
    }, []);
  }; // helper function to extract suggestions

  var extractSuggestion = function extractSuggestion(val) {
    if (typeof val === 'object') {
      if (Array.isArray(val)) {
        return flatten(val);
      }

      return null;
    }

    return val;
  };

  function escapeRegExp(string) {
    if (string === void 0) {
      string = '';
    }

    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // $& means the whole matched string
  }

  var getPredictiveSuggestions = function getPredictiveSuggestions(_ref) {
    var suggestions = _ref.suggestions,
        currentValue = _ref.currentValue,
        wordsToShowAfterHighlight = _ref.wordsToShowAfterHighlight;
    var suggestionMap = {};

    if (currentValue) {
      var currentValueTrimmed = currentValue.trim();
      var parsedSuggestion = suggestions.reduce(function (agg, _ref2) {
        var label = _ref2.label,
            rest = _objectWithoutPropertiesLoose(_ref2, ["label"]);

        // to handle special strings with pattern '<mark>xyz</mark> <a href="test'
        var parsedContent = new DOMParser().parseFromString(label, 'text/html').documentElement.textContent; // to match the partial start of word.
        // example if searchTerm is `select` and string contains `selected`

        var regexString = "^(" + escapeRegExp(currentValueTrimmed) + ")\\w+";
        var regex = new RegExp(regexString, 'i');
        var regexExecution = regex.exec(parsedContent); // if execution value is null it means either there is no match or there are chances
        // that exact word is present

        if (!regexExecution) {
          // regex to match exact word
          regexString = "^(" + escapeRegExp(currentValueTrimmed) + ")";
          regex = new RegExp(regexString, 'i');
          regexExecution = regex.exec(parsedContent);
        }

        if (regexExecution) {
          var matchedString = parsedContent.slice(regexExecution.index, parsedContent.length);
          var highlightedWord = matchedString.slice(currentValueTrimmed.length).split(' ').slice(0, wordsToShowAfterHighlight + 1).join(' ');
          var suggestionPhrase = currentValueTrimmed + "<mark class=\"highlight\">" + highlightedWord + "</mark>";
          var suggestionValue = "" + currentValueTrimmed + highlightedWord; // to show unique results only

          if (!suggestionMap[suggestionPhrase]) {
            suggestionMap[suggestionPhrase] = 1;
            return [].concat(agg, [_extends({}, rest, {
              label: suggestionPhrase,
              value: suggestionValue,
              isPredictiveSuggestion: true
            })]);
          }

          return agg;
        }

        return agg;
      }, []);
      return parsedSuggestion;
    }

    return [];
  };
  /**
   *
   * @param {array} fields DataFields passed on Search Components
   * @param {array} suggestions Raw Suggestions received from ES
   * @param {string} currentValue Search Term
   * @param {boolean} showDistinctSuggestions When set to true will only return 1 suggestion per document
   * @param {boolean} enablePredictiveSuggestions When set to true will return the predictive suggestions list instead of the deafult list
   */

  var getSuggestions = function getSuggestions(fields, suggestions, value, showDistinctSuggestions, enablePredictiveSuggestions) {
    if (fields === void 0) {
      fields = [];
    }

    if (value === void 0) {
      value = '';
    }

    if (showDistinctSuggestions === void 0) {
      showDistinctSuggestions = true;
    }

    if (enablePredictiveSuggestions === void 0) {
      enablePredictiveSuggestions = false;
    }

    var suggestionsList = [];
    var labelsList = [];
    var skipWordMatch = false; //  Use to skip the word match logic, important for synonym

    var currentValue = value || '';

    var populateSuggestionsList = function populateSuggestionsList(val, parsedSource, source) {
      // check if the suggestion includes the current value
      // and not already included in other suggestions
      var isWordMatch = skipWordMatch || currentValue.trim().split(' ').some(function (term) {
        return String(val).toLowerCase().includes(term);
      }); // promoted results should always include in suggestions even there is no match

      if (isWordMatch && !labelsList.includes(val) || source._promoted) {
        var defaultOption = {
          label: val,
          value: val,
          source: source
        };

        var option = _extends({}, defaultOption);

        labelsList = [].concat(labelsList, [val]);
        suggestionsList = [].concat(suggestionsList, [option]);

        if (showDistinctSuggestions) {
          return true;
        }
      }

      return false;
    };

    var parseField = function parseField(parsedSource, field, source) {
      if (field === void 0) {
        field = '';
      }

      if (source === void 0) {
        source = parsedSource;
      }

      if (typeof parsedSource === 'object') {
        var fieldNodes = field.split('.');
        var label = parsedSource[fieldNodes[0]];

        if (label) {
          if (fieldNodes.length > 1) {
            // nested fields of the 'foo.bar.zoo' variety
            var children = field.substring(fieldNodes[0].length + 1);

            if (Array.isArray(label)) {
              label.forEach(function (arrayItem) {
                parseField(arrayItem, children, source);
              });
            } else {
              parseField(label, children, source);
            }
          } else {
            var val = extractSuggestion(label);

            if (val) {
              if (Array.isArray(val)) {
                if (showDistinctSuggestions) {
                  return val.some(function (suggestion) {
                    return populateSuggestionsList(suggestion, parsedSource, source);
                  });
                }

                val.forEach(function (suggestion) {
                  return populateSuggestionsList(suggestion, parsedSource, source);
                });
              }

              return populateSuggestionsList(val, parsedSource, source);
            }
          }
        }
      }

      return false;
    };

    var traverseSuggestions = function traverseSuggestions() {
      if (showDistinctSuggestions) {
        suggestions.forEach(function (item) {
          fields.some(function (field) {
            return parseField(item, field);
          });
        });
      } else {
        suggestions.forEach(function (item) {
          fields.forEach(function (field) {
            parseField(item, field);
          });
        });
      }
    };

    traverseSuggestions();

    if (suggestionsList.length < suggestions.length && !skipWordMatch) {
      /*
      When we have synonym we set skipWordMatch to false as it may discard
      the suggestion if word doesnt match term.
      For eg: iphone, ios are synonyms and on searching iphone isWordMatch
      in  populateSuggestionList may discard ios source which decreases no.
      of items in suggestionsList
      */
      skipWordMatch = true;
      traverseSuggestions();
    }

    if (enablePredictiveSuggestions) {
      return getPredictiveSuggestions({
        suggestions: suggestionsList,
        currentValue: value,
        wordsToShowAfterHighlight: true
      });
    }

    return suggestionsList;
  };
  function parseCompAggToHits(aggFieldName, buckets) {
    if (buckets === void 0) {
      buckets = [];
    }

    return buckets.map(function (bucket) {
      // eslint-disable-next-line camelcase
      var doc_count = bucket.doc_count,
          key = bucket.key,
          data = bucket[aggFieldName];
      return _extends({
        _doc_count: doc_count,
        // To handle the aggregation results for term and composite aggs
        _key: key[aggFieldName] !== undefined ? key[aggFieldName] : key
      }, data);
    });
  }
  function isEqual(x, y) {
    if (x === y) return true;
    if (!(x instanceof Object) || !(y instanceof Object)) return false;
    if (x.constructor !== y.constructor) return false;
    /* eslint-disable */

    for (var p in x) {
      if (!x.hasOwnProperty(p)) continue;
      if (!y.hasOwnProperty(p)) return false;
      if (x[p] === y[p]) continue;
      if (typeof x[p] !== 'object') return false;
      if (!isEqual(x[p], y[p])) return false;
    }

    for (var _p in y) {
      if (y.hasOwnProperty(_p) && !x.hasOwnProperty(_p)) return false;
    }
    /* eslint-enable */


    return true;
  }
  var searchBaseMappings = {
    id: 'id',
    type: 'type',
    react: 'react',
    queryFormat: 'queryFormat',
    dataField: 'dataField',
    categoryField: 'categoryField',
    categoryValue: 'categoryValue',
    nestedField: 'nestedField',
    from: 'from',
    size: 'size',
    sortBy: 'sortBy',
    value: 'value',
    aggregationField: 'aggregationField',
    aggregationSize: 'aggregationSize',
    after: 'after',
    includeNullValues: 'includeNullValues',
    includeFields: 'includeFields',
    excludeFields: 'excludeFields',
    fuzziness: 'fuzziness',
    searchOperators: 'searchOperators',
    highlight: 'highlight',
    highlightField: 'highlightField',
    customHighlight: 'customHighlight',
    interval: 'interval',
    aggregations: 'aggregations',
    missingLabel: 'missingLabel',
    showMissing: 'showMissing',
    enableSynonyms: 'enableSynonyms',
    selectAllLabel: 'selectAllLabel',
    pagination: 'pagination',
    queryString: 'queryString',
    enablePopularSuggestions: 'enablePopularSuggestions',
    showDistinctSuggestions: 'showDistinctSuggestions',
    error: 'error',
    defaultQuery: 'defaultQuery',
    customQuery: 'customQuery',
    requestStatus: 'requestStatus',
    results: 'results',
    aggregationData: 'aggregationData',
    micStatus: 'micStatus',
    micInstance: 'micInstance',
    micActive: 'micActive',
    micInactive: 'micInactive',
    micDenied: 'micDenied',
    query: 'query',
    requestPending: 'loading',
    appbaseSettings: 'appbaseConfig',
    suggestions: 'suggestions',
    queryId: 'queryId',
    recentSearches: 'recentSearches',
    distinctField: 'distinctField',
    distinctFieldConfig: 'distinctFieldConfig',
    // ---------------- Methods -----------------------
    onMicClick: 'handleMicClick',
    triggerDefaultQuery: 'triggerDefaultQuery',
    triggerCustomQuery: 'triggerCustomQuery',
    recordClick: 'recordClick',
    recordConversions: 'recordConversions',
    subscribeToStateChanges: 'subscribeToStateChanges',
    unsubscribeToStateChanges: 'unsubscribeToStateChanges',
    // ---------------- Setter Methods ----------------
    setDataField: 'setDataField',
    setValue: 'setValue',
    setSize: 'setSize',
    setFrom: 'setFrom',
    setFuzziness: 'setFuzziness',
    setIncludeFields: 'setIncludeFields',
    setExcludeFields: 'setExcludeFields',
    setSortBy: 'setSortBy',
    setReact: 'setReact',
    setDefaultQuery: 'setDefaultQuery',
    setCustomQuery: 'setCustomQuery',
    setAfter: 'setAfter'
  };
  function btoa$1(input) {
    if (input === void 0) {
      input = '';
    }

    var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    var str = input;
    var output = ''; // eslint-disable-next-line

    for (var block = 0, charCode, i = 0, map = chars; str.charAt(i | 0) || (map = '=', i % 1); // eslint-disable-line no-bitwise
    output += map.charAt(63 & block >> 8 - i % 1 * 8) // eslint-disable-line no-bitwise
    ) {
      charCode = str.charCodeAt(i += 3 / 4);

      if (charCode > 0xff) {
        throw new Error('"btoa" failed: The string to be encoded contains characters outside of the Latin1 range.');
      }

      block = block << 8 | charCode; // eslint-disable-line no-bitwise
    }

    return output;
  }

  /**
   * Base class is the abstract class for SearchBase and SearchComponent classes.
   */
  var Base = /*#__PURE__*/function () {
    // to enable the recording of analytics
    // auth credentials if any
    // custom headers object
    // es index name
    // es url

    /* ---- callbacks to create the side effects while querying ----- */

    /* ------ Private properties only for the internal use ----------- */
    // analytics instance
    // query search ID
    function Base(_ref) {
      var index$1 = _ref.index,
          url = _ref.url,
          credentials = _ref.credentials,
          headers = _ref.headers,
          appbaseConfig = _ref.appbaseConfig,
          transformRequest = _ref.transformRequest,
          transformResponse = _ref.transformResponse;

      if (!index$1) {
        throw new Error(errorMessages.invalidIndex);
      }

      if (!url) {
        throw new Error(errorMessages.invalidURL);
      }

      this.index = index$1;
      this.url = url;
      this.credentials = credentials || '';

      if (appbaseConfig) {
        this.appbaseConfig = appbaseConfig;
      }

      if (transformRequest) {
        this.transformRequest = transformRequest;
      }

      if (transformResponse) {
        this.transformResponse = transformResponse;
      } // Initialize headers


      this.headers = {
        Accept: 'application/json',
        'Content-Type': 'application/json'
      };

      if (this.credentials) {
        this.headers = _extends({}, this.headers, {
          Authorization: "Basic " + btoa$1(this.credentials)
        });
      }

      if (headers) {
        this.setHeaders(headers);
      } // Create analytics index


      this._analyticsInstance = index.init({
        index: index$1,
        url: url,
        credentials: credentials
      });
    } // To to set the custom headers


    var _proto = Base.prototype;

    _proto.setHeaders = function setHeaders(headers) {
      this.headers = _extends({}, this.headers, headers);
    } // To set the query ID
    ;

    _proto.setQueryID = function setQueryID(queryID) {
      this._queryId = queryID;
    };

    return Base;
  }();

  var Results = /*#__PURE__*/function () {
    // An array of results obtained from the applied query.
    // Raw response returned by ES query
    // Results parser
    function Results(data) {
      var _this = this;

      _defineProperty(this, "setRaw", function (rawResponse) {
        // set response
        _this.raw = rawResponse;

        if (rawResponse.hits && rawResponse.hits.hits) {
          _this.setData(rawResponse.hits.hits);
        }
      });

      this.data = data || [];
    } // Total number of results found


    var _proto = Results.prototype;

    // Method to set data explicitly
    _proto.setData = function setData(data) {
      // parse hits
      var filteredResults = parseHits(data); // filter results & remove duplicates if any

      if (this.promotedData.length) {
        var ids = this.promotedData.map(function (item) {
          return item._id;
        }).filter(Boolean);

        if (ids) {
          filteredResults = filteredResults.filter(function (item) {
            return !ids.includes(item._id);
          });
        }

        filteredResults = [].concat(this.promotedData.map(function (dataItem) {
          return _extends({}, dataItem, {
            _promoted: true
          });
        }), filteredResults);
      } // set data


      if (this.parseResults) {
        this.data = this.parseResults(filteredResults, data);
      } else {
        this.data = filteredResults;
      } // Add click ids in data


      this.data = withClickIds(this.data);
    };

    _createClass(Results, [{
      key: "numberOfResults",
      get: function get() {
        // calculate from raw response
        if (this.raw && this.raw.hits) {
          return typeof this.raw.hits.total === 'object' ? this.raw.hits.total.value : this.raw.hits.total;
        }

        return 0;
      } // Total time taken by request (in ms)

    }, {
      key: "time",
      get: function get() {
        // calculate from raw response
        if (this.raw) {
          return this.raw.took;
        }

        return 0;
      } // no of hidden results found

    }, {
      key: "hidden",
      get: function get() {
        if (this.raw && this.raw.hits) {
          return this.raw.hits.hidden || 0;
        }

        return 0;
      } // An array of promoted results obtained from the applied query.

    }, {
      key: "promotedData",
      get: function get() {
        if (this.raw && this.raw.promoted) {
          return this.raw.promoted || [];
        }

        return [];
      } // no of promoted results found

    }, {
      key: "promoted",
      get: function get() {
        return this.promotedData.length || 0;
      } // An object of raw response as-is from elasticsearch query

    }, {
      key: "rawData",
      get: function get() {
        return this.raw || {};
      } // object of custom data applied through queryRules
      // only works when `enableAppbase=true`

    }, {
      key: "customData",
      get: function get() {
        if (this.raw && this.raw.customData) {
          return this.raw.customData || {};
        }

        return {};
      }
    }]);

    return Results;
  }();

  var Aggregations = /*#__PURE__*/function () {
    // An array of composite aggregations obtained from the applied aggs in options.
    // useful when loading data of greater size
    // Raw aggregations returned by ES query
    function Aggregations(data) {
      this.data = data || [];
    } // An object of raw response as-is from elasticsearch query


    var _proto = Aggregations.prototype;

    _proto.setRaw = function setRaw(rawResponse) {
      // set response
      this.raw = rawResponse;
      if (rawResponse.after_key) this.setAfterKey(rawResponse.after_key);
    };

    _proto.setAfterKey = function setAfterKey(key) {
      this.afterKey = key;
    } // Method to set data explicitly
    ;

    _proto.setData = function setData(aggField, data, append) {
      if (append === void 0) {
        append = false;
      }

      // parse aggregation buckets
      var parsedData = parseCompAggToHits(aggField, data); // Merge data

      if (append) {
        this.data = [].concat(this.data, parsedData);
      } else {
        this.data = parsedData;
      }
    };

    _createClass(Aggregations, [{
      key: "rawData",
      get: function get() {
        return this.raw || {};
      }
    }]);

    return Aggregations;
  }();

  var defaultOptions = {
    triggerDefaultQuery: true,
    triggerCustomQuery: false,
    stateChanges: true
  };
  var defaultOption = {
    stateChanges: true
  };
  var MIC_STATUS = {
    inactive: 'INACTIVE',
    active: 'ACTIVE',
    denied: 'DENIED'
  };
  var REQUEST_STATUS = {
    inactive: 'INACTIVE',
    pending: 'PENDING',
    error: 'ERROR'
  };
  var suggestionQueryID = 'DataSearch__suggestions';
  /**
   * SearchComponent class is responsible for the following things:
   * - It provides the methods to trigger the query
   * - It maintains the request state for e.g loading, error etc.
   * - It handles the `custom` and `default` queries
   * - Basically the SearchComponent class provides all the utilities to build any ReactiveSearch component
   */

  var SearchComponent = /*#__PURE__*/function (_Base) {
    _inheritsLoose(SearchComponent, _Base);

    // RS API properties
    // other properties
    // To enable the popular suggestions
    // size of the popular suggestions
    // To show the distinct suggestions
    // To show the predictive suggestions
    // preserve the data for infinite loading
    // to clear the dependent facets values on query change
    // query error
    // state changes subject
    // request status
    // results
    // aggregations
    // recent searches

    /* ------ Private properties only for the internal use ----------- */
    // Counterpart of the query
    // TODO: Check on the below properties
    // mic status
    // mic instance
    // query search ID
    // tracks the last request time for default query
    // tracks the last request time for custom query

    /* ---- callbacks to create the side effects while querying ----- */

    /* ------------- change events -------------------------------- */
    // called when value changes
    // called when results change
    // called when composite aggregationData change
    // called when there is an error while fetching results
    // called when request status changes
    // called when query changes
    // called when mic status changes
    function SearchComponent(_ref) {
      var _this;

      var index = _ref.index,
          url = _ref.url,
          credentials = _ref.credentials,
          appbaseConfig = _ref.appbaseConfig,
          headers = _ref.headers,
          transformRequest = _ref.transformRequest,
          transformResponse = _ref.transformResponse,
          beforeValueChange = _ref.beforeValueChange,
          onValueChange = _ref.onValueChange,
          onResults = _ref.onResults,
          onAggregationData = _ref.onAggregationData,
          onError = _ref.onError,
          onRequestStatusChange = _ref.onRequestStatusChange,
          onQueryChange = _ref.onQueryChange,
          onMicStatusChange = _ref.onMicStatusChange,
          enablePopularSuggestions = _ref.enablePopularSuggestions,
          maxPopularSuggestions = _ref.maxPopularSuggestions,
          _results = _ref.results,
          showDistinctSuggestions = _ref.showDistinctSuggestions,
          enablePredictiveSuggestions = _ref.enablePredictiveSuggestions,
          preserveResults = _ref.preserveResults,
          clearOnQueryChange = _ref.clearOnQueryChange,
          rsAPIConfig = _objectWithoutPropertiesLoose(_ref, ["index", "url", "credentials", "appbaseConfig", "headers", "transformRequest", "transformResponse", "beforeValueChange", "onValueChange", "onResults", "onAggregationData", "onError", "onRequestStatusChange", "onQueryChange", "onMicStatusChange", "enablePopularSuggestions", "maxPopularSuggestions", "results", "showDistinctSuggestions", "enablePredictiveSuggestions", "preserveResults", "clearOnQueryChange"]);

      _this = _Base.call(this, {
        index: index,
        url: url,
        credentials: credentials,
        headers: headers,
        appbaseConfig: appbaseConfig,
        transformRequest: transformRequest,
        transformResponse: transformResponse
      }) || this;

      _defineProperty(_assertThisInitialized(_this), "onMicClick", function (micOptions, options) {
        if (micOptions === void 0) {
          micOptions = {};
        }

        if (options === void 0) {
          options = {
            triggerDefaultQuery: false,
            triggerCustomQuery: false,
            stateChanges: true
          };
        }

        var prevStatus = _this._micStatus;

        if (typeof window !== 'undefined') {
          window.SpeechRecognition = window.webkitSpeechRecognition || window.SpeechRecognition || null;
        }

        if (window && window.SpeechRecognition && prevStatus !== MIC_STATUS.denied) {
          if (prevStatus === MIC_STATUS.active) {
            _this._setMicStatus(MIC_STATUS.inactive, options);
          }

          var _window = window,
              SpeechRecognition = _window.SpeechRecognition;

          if (_this._micInstance) {
            _this._stopMic();

            return;
          }

          _this._micInstance = new SpeechRecognition();
          _this._micInstance.continuous = true;
          _this._micInstance.interimResults = true;
          Object.assign(_this._micInstance, micOptions);

          _this._micInstance.start();

          _this._micInstance.onstart = function () {
            _this._setMicStatus(MIC_STATUS.active, options);
          };

          _this._micInstance.onresult = function (_ref2) {
            var results = _ref2.results;

            if (results && results[0] && results[0].isFinal) {
              _this._stopMic();
            }

            _this._handleVoiceResults({
              results: results
            }, options);
          };

          _this._micInstance.onerror = function (e) {
            if (e.error === 'no-speech' || e.error === 'audio-capture') {
              _this._setMicStatus(MIC_STATUS.inactive, options);
            } else if (e.error === 'not-allowed') {
              _this._setMicStatus(MIC_STATUS.denied, options);
            }

            console.error(e);
          };
        }
      });

      _defineProperty(_assertThisInitialized(_this), "setDataField", function (dataField, options) {
        if (options === void 0) {
          options = defaultOptions;
        }

        var prev = _this.dataField;
        _this.dataField = dataField;

        _this._applyOptions(options, 'dataField', prev, dataField);
      });

      _defineProperty(_assertThisInitialized(_this), "setParent", function (parent) {
        _this._parent = parent;
      });

      _defineProperty(_assertThisInitialized(_this), "setValue", function (value, options) {
        if (options === void 0) {
          options = defaultOptions;
        }

        var performUpdate = function performUpdate() {
          var prev = _this.value;
          _this.value = value;

          _this._applyOptions(options, 'value', prev, _this.value);
        };

        if (_this.beforeValueChange) {
          _this.beforeValueChange(value).then(performUpdate)["catch"](function (e) {
            console.warn('beforeValueChange rejected the promise with ', e);
          });
        } else {
          performUpdate();
        }
      });

      _defineProperty(_assertThisInitialized(_this), "setSize", function (size, options) {
        if (options === void 0) {
          options = defaultOptions;
        }

        var prev = _this.size;
        _this.size = size;

        _this._applyOptions(options, 'size', prev, _this.size);
      });

      _defineProperty(_assertThisInitialized(_this), "setFrom", function (from, options) {
        if (options === void 0) {
          options = defaultOptions;
        }

        var prev = _this.from;
        _this.from = from;

        _this._applyOptions(options, 'from', prev, _this.from);
      });

      _defineProperty(_assertThisInitialized(_this), "setFuzziness", function (fuzziness, options) {
        if (options === void 0) {
          options = defaultOptions;
        }

        var prev = _this.fuzziness;
        _this.fuzziness = fuzziness;

        _this._applyOptions(options, 'fuzziness', prev, _this.fuzziness);
      });

      _defineProperty(_assertThisInitialized(_this), "setIncludeFields", function (includeFields, options) {
        if (options === void 0) {
          options = defaultOptions;
        }

        var prev = _this.includeFields;
        _this.includeFields = includeFields;

        _this._applyOptions(options, 'includeFields', prev, includeFields);
      });

      _defineProperty(_assertThisInitialized(_this), "setExcludeFields", function (excludeFields, options) {
        if (options === void 0) {
          options = defaultOptions;
        }

        var prev = _this.excludeFields;
        _this.excludeFields = excludeFields;

        _this._applyOptions(options, 'excludeFields', prev, excludeFields);
      });

      _defineProperty(_assertThisInitialized(_this), "setSortBy", function (sortBy, options) {
        if (options === void 0) {
          options = defaultOptions;
        }

        var prev = _this.sortBy;
        _this.sortBy = sortBy;

        _this._applyOptions(options, 'sortBy', prev, sortBy);
      });

      _defineProperty(_assertThisInitialized(_this), "setReact", function (react, options) {
        if (options === void 0) {
          options = defaultOptions;
        }

        var prev = _this.react;
        _this.react = react;

        _this._applyOptions(options, 'react', prev, react);
      });

      _defineProperty(_assertThisInitialized(_this), "setDefaultQuery", function (defaultQuery, options) {
        if (options === void 0) {
          options = defaultOptions;
        }

        var prev = _this.defaultQuery;
        _this.defaultQuery = defaultQuery;

        _this._applyOptions(options, 'defaultQuery', prev, defaultQuery);
      });

      _defineProperty(_assertThisInitialized(_this), "setCustomQuery", function (customQuery, options) {
        if (options === void 0) {
          options = defaultOptions;
        }

        var prev = _this.customQuery;
        _this.customQuery = customQuery;

        _this._applyOptions(options, 'customQuery', prev, customQuery);
      });

      _defineProperty(_assertThisInitialized(_this), "setAfter", function (after, options) {
        if (options === void 0) {
          options = defaultOptions;
        }

        var prev = _this.after;
        _this.after = after;

        _this.aggregationData.setAfterKey(after);

        _this._applyOptions(options, 'after', prev, after);
      });

      _defineProperty(_assertThisInitialized(_this), "triggerDefaultQuery", function (options) {
        if (options === void 0) {
          options = defaultOption;
        }

        // To prevent duplicate queries
        if (isEqual(_this._query, _this.componentQuery)) {
          return Promise.resolve(true);
        }

        var handleError = function handleError(err) {
          _this._setError(err, {
            stateChanges: options.stateChanges
          });

          console.error(err);
          return Promise.reject(err);
        };

        try {
          _this._updateQuery();

          _this._setRequestStatus(REQUEST_STATUS.pending); // Set the latest request time


          _this._lastRequestTimeDefaultQuery = new Date().getTime();
          return _this._fetchRequest({
            query: Array.isArray(_this.query) ? _this.query : [_this.query],
            settings: _this.appbaseSettings
          }).then(function (results) {
            if (_this._lastRequestTimeDefaultQuery < results._timestamp) {
              var _prev = _this.results;
              var rawResults = results && results[_this.id];

              var afterResponse = function afterResponse() {
                if (rawResults.aggregations) {
                  _this._handleAggregationResponse(rawResults.aggregations, _extends({
                    defaultOptions: defaultOptions
                  }, options));
                }

                _this._setRequestStatus(REQUEST_STATUS.inactive);

                _this._applyOptions({
                  stateChanges: options.stateChanges
                }, 'results', _prev, _this.results);
              };

              if ((!_this.type || _this.type === queryTypes.Search) && _this.enablePopularSuggestions) {
                _this._fetchRequest(_this.getSuggestionsQuery(), true).then(function (rawPopularSuggestions) {
                  var popularSuggestionsData = rawPopularSuggestions[suggestionQueryID]; // Merge popular suggestions as the top suggestions

                  if (popularSuggestionsData && popularSuggestionsData.hits && popularSuggestionsData.hits.hits && rawResults.hits && rawResults.hits.hits) {
                    rawResults.hits.hits = [].concat((popularSuggestionsData.hits.hits || []).map(function (hit) {
                      return _extends({}, hit, {
                        // Set the popular suggestion tag for suggestion hits
                        _popular_suggestion: true
                      });
                    }), rawResults.hits.hits);
                  }

                  _this._appendResults(rawResults);

                  afterResponse();
                })["catch"](handleError);
              } else {
                _this._appendResults(rawResults);

                afterResponse();
              }

              return Promise.resolve(rawResults);
            }

            return Promise.resolve([]);
          })["catch"](handleError);
        } catch (err) {
          return handleError(err);
        }
      });

      _defineProperty(_assertThisInitialized(_this), "triggerCustomQuery", function (options) {
        if (options === void 0) {
          options = defaultOption;
        }

        // Generate query again after resetting changes
        var _this$_generateQuery = _this._generateQuery(),
            requestBody = _this$_generateQuery.requestBody,
            orderOfQueries = _this$_generateQuery.orderOfQueries;

        if (requestBody.length) {
          if (isEqual(_this._query, requestBody)) {
            return Promise.resolve(true);
          }

          var handleError = function handleError(err) {
            _this._setError(err, {
              stateChanges: options.stateChanges
            });

            console.error(err);
            return Promise.reject(err);
          };

          try {
            // set the request loading to true for all the requests
            orderOfQueries.forEach(function (id) {
              var componentInstance = _this._parent.getComponent(id);

              if (componentInstance) {
                // Reset `from` and `after` values
                componentInstance.setFrom(0, {
                  stateChanges: true,
                  triggerDefaultQuery: false,
                  triggerCustomQuery: false
                });
                componentInstance.setAfter(undefined, {
                  stateChanges: true,
                  triggerDefaultQuery: false,
                  triggerCustomQuery: false
                }); // Reset value for dependent components after fist query is made
                // We wait for first query to not clear filters applied by URL params

                if (_this.clearOnQueryChange && _this._query) {
                  componentInstance.setValue(undefined, {
                    stateChanges: true,
                    triggerDefaultQuery: false,
                    triggerCustomQuery: false
                  });
                }

                componentInstance._setRequestStatus(REQUEST_STATUS.pending); // Update the query


                componentInstance._updateQuery();
              }
            }); // Set the latest request time

            _this._lastRequestTimeCustomQuery = new Date().getTime(); // Re-generate query after changes

            var _this$_generateQuery2 = _this._generateQuery(),
                finalRequest = _this$_generateQuery2.requestBody;

            return _this._fetchRequest({
              query: finalRequest,
              settings: _this.appbaseSettings
            }).then(function (results) {
              if (_this._lastRequestTimeCustomQuery < results._timestamp) {
                // Update the state for components
                orderOfQueries.forEach(function (id) {
                  var componentInstance = _this._parent.getComponent(id);

                  if (componentInstance) {
                    componentInstance._setRequestStatus(REQUEST_STATUS.inactive); // Update the results


                    var _prev2 = componentInstance.results; // Collect results from the response for a particular component

                    var rawResults = results && results[id]; // Set results

                    if (rawResults.hits) {
                      componentInstance.results.setRaw(rawResults);

                      componentInstance._applyOptions({
                        stateChanges: options.stateChanges
                      }, 'results', _prev2, componentInstance.results);
                    }

                    if (rawResults.aggregations) {
                      componentInstance._handleAggregationResponse(rawResults.aggregations, _extends({
                        defaultOptions: defaultOptions
                      }, options), false);
                    }
                  }
                });
                return Promise.resolve(results);
              }

              return Promise.resolve([]);
            })["catch"](handleError);
          } catch (err) {
            return handleError(err);
          }
        } else {
          return Promise.resolve({});
        }
      });

      _defineProperty(_assertThisInitialized(_this), "recordClick", function (objects, isSuggestionClick) {
        if (isSuggestionClick === void 0) {
          isSuggestionClick = false;
        }

        if (_this._analyticsInstance && _this.queryId) {
          _this._analyticsInstance.click({
            queryID: _this.queryId,
            objects: objects,
            isSuggestionClick: isSuggestionClick
          });
        }
      });

      _defineProperty(_assertThisInitialized(_this), "recordConversions", function (objects) {
        if (_this._analyticsInstance && _this.queryId) {
          _this._analyticsInstance.conversion({
            queryID: _this.queryId,
            objects: objects
          });
        }
      });

      _defineProperty(_assertThisInitialized(_this), "subscribeToStateChanges", function (fn, propertiesToSubscribe) {
        _this.stateChanges.subscribe(fn, propertiesToSubscribe);
      });

      _defineProperty(_assertThisInitialized(_this), "unsubscribeToStateChanges", function (fn) {
        _this.stateChanges.unsubscribe(fn);
      });

      _defineProperty(_assertThisInitialized(_this), "clearResults", function (options) {
        if (options === void 0) {
          options = defaultOption;
        }

        var prev = _this.results;

        _this.results.setRaw({
          hits: {
            hits: []
          }
        });

        _this._applyOptions({
          stateChanges: options.stateChanges
        }, 'results', prev, _this.results);
      });

      _defineProperty(_assertThisInitialized(_this), "getRecentSearches", function (queryOptions, options) {
        if (queryOptions === void 0) {
          queryOptions = {
            size: 5,
            minChars: 3
          };
        }

        if (options === void 0) {
          options = defaultOption;
        }

        var requestOptions = {
          headers: _extends({}, _this.headers)
        };
        var queryString = '';

        var addParam = function addParam(key, value) {
          if (queryString) {
            queryString += "&" + key + "=" + value;
          } else {
            queryString += key + "=" + value;
          }
        };

        if (_this.appbaseSettings && _this.appbaseSettings.userId) {
          addParam('user_id', _this.appbaseSettings.userId);
        }

        if (queryOptions) {
          if (queryOptions.size) {
            addParam('size', String(queryOptions.size));
          }

          if (queryOptions.from) {
            addParam('from', queryOptions.from);
          }

          if (queryOptions.to) {
            addParam('to', queryOptions.to);
          }

          if (queryOptions.minChars) {
            addParam('min_chars', String(queryOptions.minChars));
          }

          if (queryOptions.customEvents) {
            Object.keys(queryOptions.customEvents).forEach(function (key) {
              // $FlowFixMe
              addParam(key, queryOptions.customEvents[key]);
            });
          }
        }

        return new Promise(function (resolve, reject) {
          fetch(_this.url + "/_analytics/" + _this._getSearchIndex() + "/recent-searches?" + queryString, requestOptions).then(function (res) {
            if (res.status >= 500) {
              return reject(res);
            }

            if (res.status >= 400) {
              return reject(res);
            }

            return res.json().then(function (recentSearches) {
              var prev = _this.recentSearches;
              _this.recentSearches = recentSearches.map(function (searchObject) {
                return {
                  label: searchObject.key,
                  value: searchObject.key
                };
              });

              _this._applyOptions({
                stateChanges: options.stateChanges
              }, 'recentSearches', prev, _this.recentSearches);

              resolve(_this.recentSearches); // Populate the recent searches
            })["catch"](function (e) {
              console.warn('SearchBase: error while fetching the recent searches ', e);
              return reject(e);
            });
          })["catch"](function (e) {
            console.warn('SearchBase: error while fetching the recent searches ', e);
            return reject(e);
          });
        });
      });

      _defineProperty(_assertThisInitialized(_this), "_handleVoiceResults", function (_ref3, options) {
        var results = _ref3.results;

        if (options === void 0) {
          options = defaultOptions;
        }

        if (results && results[0] && results[0].isFinal && results[0][0] && results[0][0].transcript && results[0][0].transcript.trim()) {
          _this.setValue(results[0][0].transcript.trim(), _extends({}, options, {
            triggerCustomQuery: true,
            triggerDefaultQuery: true
          }));
        }
      });

      _defineProperty(_assertThisInitialized(_this), "_stopMic", function () {
        if (_this._micInstance) {
          _this._micInstance.stop();

          _this._micInstance = null;

          _this._setMicStatus(MIC_STATUS.inactive);
        }
      });

      _defineProperty(_assertThisInitialized(_this), "_setMicStatus", function (status, options) {
        if (options === void 0) {
          options = defaultOptions;
        }

        var prevStatus = _this._micStatus;
        _this._micStatus = status;

        _this._applyOptions(options, 'micStatus', prevStatus, _this._micStatus);
      });

      var _id = rsAPIConfig.id,
          type = rsAPIConfig.type,
          _react = rsAPIConfig.react,
          queryFormat = rsAPIConfig.queryFormat,
          _dataField = rsAPIConfig.dataField,
          categoryField = rsAPIConfig.categoryField,
          categoryValue = rsAPIConfig.categoryValue,
          nestedField = rsAPIConfig.nestedField,
          _from = rsAPIConfig.from,
          _size = rsAPIConfig.size,
          _sortBy = rsAPIConfig.sortBy,
          _value = rsAPIConfig.value,
          aggregationField = rsAPIConfig.aggregationField,
          aggregationSize = rsAPIConfig.aggregationSize,
          _after = rsAPIConfig.after,
          includeNullValues = rsAPIConfig.includeNullValues,
          _includeFields = rsAPIConfig.includeFields,
          _excludeFields = rsAPIConfig.excludeFields,
          _fuzziness = rsAPIConfig.fuzziness,
          searchOperators = rsAPIConfig.searchOperators,
          highlight = rsAPIConfig.highlight,
          highlightField = rsAPIConfig.highlightField,
          customHighlight = rsAPIConfig.customHighlight,
          interval = rsAPIConfig.interval,
          aggregations = rsAPIConfig.aggregations,
          missingLabel = rsAPIConfig.missingLabel,
          showMissing = rsAPIConfig.showMissing,
          _defaultQuery = rsAPIConfig.defaultQuery,
          _customQuery = rsAPIConfig.customQuery,
          execute = rsAPIConfig.execute,
          enableSynonyms = rsAPIConfig.enableSynonyms,
          selectAllLabel = rsAPIConfig.selectAllLabel,
          pagination = rsAPIConfig.pagination,
          _queryString = rsAPIConfig.queryString,
          distinctField = rsAPIConfig.distinctField,
          distinctFieldConfig = rsAPIConfig.distinctFieldConfig;

      if (!_id) {
        throw new Error(errorMessages.invalidComponentId);
      } // dataField is required for components other then search


      if (type && type !== queryTypes.Search) {
        if (Array.isArray(_dataField)) {
          throw new Error(errorMessages.dataFieldAsArray);
        }
      }

      _this.id = _id;
      _this.type = type;
      _this.react = _react;
      _this.queryFormat = queryFormat;
      _this.dataField = _dataField;
      _this.categoryField = categoryField;
      _this.categoryValue = categoryValue;
      _this.nestedField = nestedField;
      _this.from = _from;
      _this.size = _size;
      _this.sortBy = _sortBy;
      _this.aggregationField = aggregationField;
      _this.aggregationSize = aggregationSize;
      _this.after = _after;
      _this.includeNullValues = includeNullValues;
      _this.includeFields = _includeFields;
      _this.excludeFields = _excludeFields;
      _this.fuzziness = _fuzziness;
      _this.searchOperators = searchOperators;
      _this.highlight = highlight;
      _this.highlightField = highlightField;
      _this.customHighlight = customHighlight;
      _this.interval = interval;
      _this.aggregations = aggregations;
      _this.missingLabel = missingLabel;
      _this.showMissing = showMissing;
      _this.execute = execute;
      _this.enableSynonyms = enableSynonyms;
      _this.selectAllLabel = selectAllLabel;
      _this.pagination = pagination;
      _this.queryString = _queryString;
      _this.defaultQuery = _defaultQuery;
      _this.customQuery = _customQuery;
      _this.beforeValueChange = beforeValueChange;
      _this.onValueChange = onValueChange;
      _this.onResults = onResults;
      _this.onAggregationData = onAggregationData;
      _this.onError = onError;
      _this.onRequestStatusChange = onRequestStatusChange;
      _this.onQueryChange = onQueryChange;
      _this.onMicStatusChange = onMicStatusChange;
      _this.distinctField = distinctField;
      _this.distinctFieldConfig = distinctFieldConfig; // other properties

      _this.enablePopularSuggestions = enablePopularSuggestions;
      _this.maxPopularSuggestions = maxPopularSuggestions;
      _this.showDistinctSuggestions = showDistinctSuggestions;
      _this.enablePredictiveSuggestions = enablePredictiveSuggestions;
      _this.preserveResults = preserveResults;
      _this.clearOnQueryChange = clearOnQueryChange; // Initialize the state changes observable

      _this.stateChanges = new Observable();
      _this.results = new Results(_results);
      _this.aggregationData = new Aggregations();

      if (_value) {
        _this.setValue(_value, {
          stateChanges: true
        });
      } else {
        _this.value = _value;
      }

      return _this;
    } // getters


    var _proto = SearchComponent.prototype;

    _proto.getSuggestionsQuery = function getSuggestionsQuery() {
      return {
        query: [{
          id: suggestionQueryID,
          dataField: popularSuggestionFields,
          size: this.maxPopularSuggestions || 5,
          value: this.value,
          defaultQuery: {
            query: {
              bool: {
                minimum_should_match: 1,
                should: [{
                  function_score: {
                    field_value_factor: {
                      field: 'count',
                      modifier: 'sqrt',
                      missing: 1
                    }
                  }
                }, {
                  multi_match: {
                    fields: ['key^9', 'key.autosuggest^1', 'key.keyword^10'],
                    fuzziness: 0,
                    operator: 'or',
                    query: this.value,
                    type: 'best_fields'
                  }
                }, {
                  multi_match: {
                    fields: ['key^9', 'key.autosuggest^1', 'key.keyword^10'],
                    operator: 'or',
                    query: this.value,
                    type: 'phrase'
                  }
                }, {
                  multi_match: {
                    fields: ['key^9'],
                    operator: 'or',
                    query: this.value,
                    type: 'phrase_prefix'
                  }
                }]
              }
            }
          }
        }]
      };
    } // use this methods to record a search click event
    ;

    /* -------- Private methods only for the internal use -------- */
    _proto._appendResults = function _appendResults(rawResults) {
      if (this.preserveResults && rawResults && Array.isArray(rawResults.hits && rawResults.hits.hits) && Array.isArray(this.results.rawData && this.results.rawData.hits && this.results.rawData.hits.hits)) {
        this.results.setRaw(_extends({}, rawResults, {
          hits: _extends({}, rawResults.hits, {
            hits: [].concat(this.results.rawData.hits.hits, rawResults.hits.hits)
          })
        }));
      } else {
        this.results.setRaw(rawResults);
      }
    } // Method to apply the changed based on set options
    ;

    _proto._applyOptions = function _applyOptions(options, key, prevValue, nextValue) {
      // // Trigger mic events
      if (key === 'micStatus' && this.onMicStatusChange) {
        this.onMicStatusChange(nextValue, prevValue);
      } // Trigger events


      if (key === 'query' && this.onQueryChange) {
        this.onQueryChange(nextValue, prevValue);
      }

      if (key === 'value' && this.onValueChange) {
        this.onValueChange(nextValue, prevValue);
      }

      if (key === 'error' && this.onError) {
        this.onError(nextValue);
      }

      if (key === 'results' && this.onResults) {
        this.onResults(nextValue, prevValue);
      }

      if (key === 'aggregationData' && this.onAggregationData) {
        this.onAggregationData(nextValue, prevValue);
      }

      if (key === 'requestStatus' && this.onRequestStatusChange) {
        this.onRequestStatusChange(nextValue, prevValue);
      }

      if (options.triggerDefaultQuery) {
        this.triggerDefaultQuery();
      }

      if (options.triggerCustomQuery) {
        this.triggerCustomQuery();
      }

      if (options.stateChanges !== false) {
        var _this$stateChanges$ne;

        this.stateChanges.next((_this$stateChanges$ne = {}, _this$stateChanges$ne[key] = {
          prev: prevValue,
          next: nextValue
        }, _this$stateChanges$ne), key, this);
      }
    };

    _proto._getSearchIndex = function _getSearchIndex(isPopularSuggestionsAPI) {
      if (isPopularSuggestionsAPI === void 0) {
        isPopularSuggestionsAPI = false;
      }

      var index = this.index;

      if (isPopularSuggestionsAPI) {
        index = '.suggestions';
      } else if (this._parent && this._parent.index) {
        index = this._parent.index;
      }

      return index;
    };

    _proto._fetchRequest = function _fetchRequest(requestBody, isPopularSuggestionsAPI) {
      var _this2 = this;

      if (isPopularSuggestionsAPI === void 0) {
        isPopularSuggestionsAPI = false;
      }

      // remove undefined properties from request body
      var requestOptions = {
        method: 'POST',
        body: JSON.stringify(requestBody),
        headers: _extends({}, this.headers)
      };
      return new Promise(function (resolve, reject) {
        _this2._handleTransformRequest(requestOptions).then(function (finalRequestOptions) {
          // set timestamp in request
          var timestamp = Date.now();
          var suffix = '_reactivesearch.v3';

          var index = _this2._getSearchIndex(isPopularSuggestionsAPI);

          return fetch(_this2.url + "/" + index + "/" + suffix, finalRequestOptions).then(function (res) {
            var responseHeaders = res.headers; // check if search component is present

            if (res.headers) {
              var queryID = res.headers.get('X-Search-Id');

              if (queryID) {
                // if parent exists then set the queryID to parent
                if (_this2._parent) {
                  _this2._parent.setQueryID(queryID);
                } else {
                  _this2.setQueryID(queryID);
                }
              }
            }

            if (res.status >= 500) {
              return reject(res);
            }

            if (res.status >= 400) {
              return reject(res);
            }

            return res.json().then(function (data) {
              _this2._handleTransformResponse(data).then(function (transformedData) {
                if (transformedData && Object.prototype.hasOwnProperty.call(transformedData, 'error')) {
                  reject(transformedData);
                }

                var response = _extends({}, transformedData, {
                  _timestamp: timestamp,
                  _headers: responseHeaders
                });

                return resolve(response);
              })["catch"](function (e) {
                console.warn('SearchBase: transformResponse rejected the promise with ', e);
                return reject(e);
              });
            });
          })["catch"](function (e) {
            return reject(e);
          });
        })["catch"](function (e) {
          console.warn('SearchBase: transformRequest rejected the promise with ', e);
          return reject(e);
        });
      });
    } // Method to generate the final query based on the component's value changes
    ;

    _proto._generateQuery = function _generateQuery() {
      var _this3 = this;

      /**
       * This method performs the following tasks to generate the query
       * 1. Get all the watcher components for a particular component ID
       * 2. Make the request payload
       * 3. Execute the final query
       * 4. Update results and trigger events => Call `setResults` or `setAggregations` based on the results
       */
      if (this._parent) {
        var components = this._parent.getComponents();

        var watcherComponents = []; // Find all the  watcher components

        Object.keys(components).forEach(function (id) {
          var componentInstance = components[id];

          if (componentInstance && componentInstance.react) {
            var flattenReact = flatReactProp(componentInstance.react, id);

            if (flattenReact.indexOf(_this3.id) > -1) {
              watcherComponents.push(id);
            }
          }
        });
        var requestQuery = {}; // Generate the request body for watchers

        watcherComponents.forEach(function (watcherId) {
          var component = _this3._parent.getComponent(watcherId);

          if (component) {
            requestQuery[watcherId] = component.componentQuery; // collect queries for all components defined in the `react` property
            // that have some value defined

            var flattenReact = flatReactProp(component.react, component.id);
            flattenReact.forEach(function (id) {
              // only add if not present
              if (!requestQuery[id]) {
                var dependentComponent = _this3._parent.getComponent(id);

                if (dependentComponent && dependentComponent.value) {
                  // Set the execute to `false` for dependent components
                  var query = dependentComponent.componentQuery;
                  query.execute = false; // Add the query to request payload

                  requestQuery[id] = query;
                }
              }
            });
          }
        });
        return {
          requestBody: Object.values(requestQuery),
          orderOfQueries: watcherComponents
        };
      }

      return {
        requestBody: [],
        orderOfQueries: []
      };
    };

    _proto._handleTransformResponse = function _handleTransformResponse(res) {
      if (this.transformResponse && typeof this.transformResponse === 'function') {
        return this.transformResponse(res);
      }

      return new Promise(function (resolve) {
        return resolve(res);
      });
    };

    _proto._handleTransformRequest = function _handleTransformRequest(requestOptions) {
      if (this.transformRequest && typeof this.transformRequest === 'function') {
        return this.transformRequest(requestOptions);
      }

      return new Promise(function (resolve) {
        return resolve(requestOptions);
      });
    };

    _proto._handleAggregationResponse = function _handleAggregationResponse(aggsResponse, options, append) {
      if (options === void 0) {
        options = defaultOptions;
      }

      if (append === void 0) {
        append = true;
      }

      var aggregationField = this.aggregationField;

      if (!aggregationField && typeof this.dataField === 'string') {
        aggregationField = this.dataField;
      }

      var prev = this.aggregationData;
      this.aggregationData.setRaw(aggsResponse[aggregationField]);
      this.aggregationData.setData(aggregationField, aggsResponse[aggregationField].buckets, this.preserveResults && append);

      this._applyOptions({
        stateChanges: options.stateChanges
      }, 'aggregationData', prev, this.aggregationData);
    };

    _proto._setError = function _setError(error, options) {
      if (options === void 0) {
        options = defaultOptions;
      }

      this._setRequestStatus(REQUEST_STATUS.error);

      var prev = this.error;
      this.error = error;

      this._applyOptions(options, 'error', prev, this.error);
    };

    _proto._setRequestStatus = function _setRequestStatus(requestStatus) {
      var prev = this.requestStatus;
      this.requestStatus = requestStatus;

      this._applyOptions({
        stateChanges: true
      }, 'requestStatus', prev, this.requestStatus);
    } // Method to set the default query value
    ;

    _proto._updateQuery = function _updateQuery(query) {
      var _this4 = this;

      var prevQuery;
      prevQuery = _extends({}, this._query);
      var finalQuery = [this.componentQuery];
      var flattenReact = flatReactProp(this.react, this.id);
      flattenReact.forEach(function (id) {
        // only add if not present
        var watcherComponent = _this4._parent.getComponent(id);

        if (watcherComponent && watcherComponent.value) {
          // Set the execute to `false` for watcher components
          var watcherQuery = watcherComponent.componentQuery;
          watcherQuery.execute = false; // Add the query to request payload

          finalQuery.push(watcherQuery);
        }
      });
      this._query = query || finalQuery;

      this._applyOptions({
        stateChanges: false
      }, 'query', prevQuery, this._query);
    } // mic
    ;

    _createClass(SearchComponent, [{
      key: "micStatus",
      get: function get() {
        return this._micStatus;
      }
    }, {
      key: "micInstance",
      get: function get() {
        return this._micInstance;
      }
    }, {
      key: "micActive",
      get: function get() {
        return this._micStatus === MIC_STATUS.active;
      }
    }, {
      key: "micInactive",
      get: function get() {
        return this._micStatus === MIC_STATUS.inactive;
      }
    }, {
      key: "micDenied",
      get: function get() {
        return this._micStatus === MIC_STATUS.denied;
      }
    }, {
      key: "query",
      get: function get() {
        return this._query;
      }
    }, {
      key: "requestPending",
      get: function get() {
        return this.requestStatus === REQUEST_STATUS.pending;
      }
    }, {
      key: "appbaseSettings",
      get: function get() {
        var _ref4 = this.appbaseConfig || {},
            recordAnalytics = _ref4.recordAnalytics,
            customEvents = _ref4.customEvents,
            enableQueryRules = _ref4.enableQueryRules,
            userId = _ref4.userId;

        return {
          recordAnalytics: recordAnalytics,
          customEvents: customEvents,
          enableQueryRules: enableQueryRules,
          userId: userId
        };
      } // To get the parsed suggestions from the results

    }, {
      key: "suggestions",
      get: function get() {
        if (this.type && this.type !== queryTypes.Search) {
          return [];
        }

        if (this.results) {
          var fields = getNormalizedField(this.dataField) || [];

          if (fields.length === 0 && this.results.data && Array.isArray(this.results.data) && this.results.data.length > 0 && this.results.data[0]) {
            // Extract fields from _source
            fields = Object.keys(this.results.data[0]).filter(function (key) {
              return !['_id', '_click_id', '_index', '_score', '_type'].includes(key);
            });
          }

          if (this.enablePopularSuggestions) {
            // extract suggestions from popular suggestion fields too
            fields = [].concat(fields, popularSuggestionFields);
          }

          return getSuggestions(fields, this.results.data, this.value, this.showDistinctSuggestions, this.enablePredictiveSuggestions).slice(0, this.size);
        }

        return [];
      } // Method to get the raw query based on the current state

    }, {
      key: "componentQuery",
      get: function get() {
        return {
          id: this.id,
          type: this.type,
          dataField: getNormalizedField(this.dataField),
          react: this.react,
          highlight: this.highlight,
          highlightField: getNormalizedField(this.highlightField),
          fuzziness: this.fuzziness,
          searchOperators: this.searchOperators,
          includeFields: this.includeFields,
          excludeFields: this.excludeFields,
          size: this.size,
          from: this.from,
          queryFormat: this.queryFormat,
          sortBy: this.sortBy,
          fieldWeights: getNormalizedWeights(this.dataField),
          includeNullValues: this.includeNullValues,
          aggregationField: this.aggregationField,
          aggregationSize: this.aggregationSize,
          categoryField: this.categoryField,
          missingLabel: this.missingLabel,
          showMissing: this.showMissing,
          nestedField: this.nestedField,
          interval: this.interval,
          customHighlight: this.customHighlight,
          customQuery: this.customQuery ? this.customQuery(this) : undefined,
          defaultQuery: this.defaultQuery ? this.defaultQuery(this) : undefined,
          value: this.value,
          categoryValue: this.categoryValue,
          after: this.after,
          aggregations: this.aggregations,
          enableSynonyms: this.enableSynonyms,
          selectAllLabel: this.selectAllLabel,
          pagination: this.pagination,
          queryString: this.queryString,
          distinctField: this.distinctField,
          distinctFieldConfig: this.distinctFieldConfig,
          index: this.index
        };
      }
    }, {
      key: "queryId",
      get: function get() {
        // Get query ID from parent(searchbase) if exist
        if (this._parent && this._parent._queryId) {
          return this._parent._queryId;
        } // For single components just return the queryId from the component


        if (this._queryId) {
          return this._queryId;
        }

        return '';
      }
    }, {
      key: "mappedProps",
      get: function get() {
        var _this5 = this;

        var mappedProps = {};
        Object.keys(searchBaseMappings).forEach(function (key) {
          // $FlowFixMe
          mappedProps[searchBaseMappings[key]] = _this5[key];
        });
        return mappedProps;
      }
      /* -------- Public methods -------- */
      // mic click handler

    }]);

    return SearchComponent;
  }(Base);

  /**
   * SearchBase class will act like the ReactiveBase component.
   * It works as a centralized store that will have the info about active/registered components.
   */
  var SearchBase = /*#__PURE__*/function (_Base) {
    _inheritsLoose(SearchBase, _Base);

    /* ------ Private properties only for the internal use ----------- */
    // active components
    function SearchBase(_ref) {
      var _this;

      var index = _ref.index,
          url = _ref.url,
          credentials = _ref.credentials,
          headers = _ref.headers,
          appbaseConfig = _ref.appbaseConfig;
      _this = _Base.call(this, {
        index: index,
        url: url,
        credentials: credentials,
        headers: headers,
        appbaseConfig: appbaseConfig
      }) || this;

      _defineProperty(_assertThisInitialized(_this), "register", function (componentId, component) {
        if (!componentId) {
          throw new Error(errorMessages.invalidComponentId);
        }

        if (_this._components[componentId]) {
          // return existing instance
          return _this._components[componentId];
        }

        var componentInstance = component;

        if (component && !(component instanceof SearchComponent)) {
          // create instance from object with all the options
          componentInstance = new SearchComponent(_extends({}, component, {
            id: componentId,
            index: component.index || _this.index,
            url: component.url || _this.url,
            credentials: component.credentials || _this.credentials,
            headers: component.headers || _this.headers,
            transformRequest: component.transformRequest || _this.transformRequest,
            transformResponse: component.transformResponse || _this.transformResponse,
            appbaseConfig: component.appbaseConfig || _this.appbaseConfig
          }));
        } else {
          // set the id property on instance
          componentInstance.id = componentId;
        } // register component


        _this._components[componentId] = componentInstance; // set the search base instance as parent

        componentInstance.setParent(_assertThisInitialized(_this));
        return componentInstance;
      });

      _defineProperty(_assertThisInitialized(_this), "unregister", function (componentId) {
        if (componentId) {
          delete _this._components[componentId];
        }
      });

      _defineProperty(_assertThisInitialized(_this), "getComponent", function (componentId) {
        return _this._components[componentId];
      });

      _defineProperty(_assertThisInitialized(_this), "getComponents", function () {
        return _this._components;
      });

      _this._components = {};
      return _this;
    } // To register a component


    return SearchBase;
  }(Base);

  exports.SearchBase = SearchBase;
  exports.SearchComponent = SearchComponent;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=searchbase.umd.js.map
